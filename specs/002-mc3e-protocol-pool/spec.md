# Feature Specification: MC 3E ASCII 프로토콜 통신 및 Connection Pool

**Feature Branch**: `002-mc3e-protocol-pool`
**Created**: 2025-10-31
**Status**: Draft
**Input**: User description: "Python 백엔드 - MC 3E ASCII 프로토콜 통신 및 Connection Pool: Mitsubishi Q Series PLC와 MC 3E ASCII 프로토콜로 TCP/IP 통신. PLC당 5개 연결을 재사용하는 Connection Pool 구현. pymcprotocol 라이브러리 사용. 배치 읽기로 10-50개 태그를 한 번에 조회. 연결 상태 확인 및 자동 재연결. 타임아웃 처리. 기존 SQLite DB의 plc_connections 테이블과 tags 테이블 활용. 연결 실패 시 로깅 및 재시도 로직. 성능: 태그당 평균 응답시간 50ms 이하."

## User Scenarios & Testing *(mandatory)*

### User Story 1 - PLC 연결 및 단일 태그 읽기 (Priority: P1) 🎯 MVP

시스템이 Mitsubishi Q Series PLC와 TCP/IP로 연결하여 단일 태그 값을 읽을 수 있다.

**Why this priority**: 모든 PLC 통신의 기본이 되는 핵심 기능. 이것이 작동하지 않으면 다른 모든 기능이 불가능하다. 연결과 기본 읽기가 검증되면 MVP로서 가치를 제공할 수 있다.

**Independent Test**: SQLite DB에 등록된 PLC 정보(IP, 포트)로 연결하고, 하나의 태그 주소(예: D100)를 읽어서 값을 반환하는지 확인. 연결 성공/실패 로그 확인.

**Acceptance Scenarios**:

1. **Given** SQLite DB에 PLC 연결 정보가 등록되어 있음 (IP: 192.168.1.10, 포트: 5010), **When** 시스템이 해당 PLC에 연결을 시도하고 태그 D100 값을 읽음, **Then** 연결이 성공하고 태그 값이 정상적으로 반환됨
2. **Given** PLC 연결 정보가 잘못되었거나 PLC가 응답하지 않음, **When** 시스템이 연결을 시도함, **Then** 타임아웃 후 연결 실패 로그가 기록되고 에러가 반환됨
3. **Given** PLC와 연결이 성공한 상태, **When** 존재하지 않는 태그 주소를 읽으려고 함, **Then** PLC 에러 응답이 반환되고 로그에 기록됨

---

### User Story 2 - Connection Pool을 통한 연결 재사용 (Priority: P1) 🎯 MVP

PLC당 5개의 연결을 풀로 관리하여 매번 새로 연결하지 않고 기존 연결을 재사용한다.

**Why this priority**: 성능 최적화의 핵심. 매번 새 연결을 생성하면 오버헤드가 크고 PLC에 부담을 준다. MVP 단계에서 성능 요구사항(태그당 50ms)을 충족하려면 필수적이다.

**Independent Test**: 동일한 PLC에 대해 10개의 연속 읽기 요청을 보내고, Connection Pool에서 연결이 재사용되는지 확인 (새 연결 생성이 최대 5개까지만 발생하는지 확인).

**Acceptance Scenarios**:

1. **Given** PLC01에 대해 Connection Pool이 초기화되어 있음 (최대 5개 연결), **When** 첫 번째 태그 읽기 요청이 들어옴, **Then** 새 연결이 생성되고 풀에 추가됨
2. **Given** PLC01 풀에 이미 2개의 연결이 있음, **When** 새로운 태그 읽기 요청 3개가 동시에 들어옴, **Then** 기존 2개 연결이 재사용되고 필요한 경우 1개의 새 연결이 생성됨
3. **Given** PLC01 풀이 최대 크기(5개)에 도달함, **When** 6번째 동시 요청이 들어옴, **Then** 사용 가능한 연결이 생길 때까지 대기하거나 적절한 에러 메시지 반환
4. **Given** 풀의 연결이 일정 시간 사용되지 않음, **When** 유휴 시간 초과, **Then** 해당 연결이 정리되고 풀에서 제거됨

---

### User Story 3 - 배치 읽기로 여러 태그 동시 조회 (Priority: P2)

한 번의 통신으로 10~50개의 태그를 배치로 읽어서 통신 횟수를 줄인다.

**Why this priority**: 성능 향상과 네트워크 효율성. 태그 수가 많을수록 배치 읽기의 효과가 크다. P1 기능이 작동한 후에 추가하면 성능을 크게 개선할 수 있다.

**Independent Test**: PLC에 연속된 태그 주소(D100~D149)를 배치로 읽기 요청하고, 한 번의 통신으로 모든 값이 반환되는지 확인. 개별 읽기 대비 응답 시간 비교.

**Acceptance Scenarios**:

1. **Given** PLC01에 D100부터 D120까지 21개의 연속된 태그가 등록되어 있음, **When** 배치 읽기 요청을 보냄, **Then** 한 번의 PLC 통신으로 모든 21개 태그 값이 반환됨
2. **Given** 배치 읽기 요청에 비연속적인 태그 주소가 포함됨 (D100, D105, D200), **When** 배치 읽기 요청, **Then** 시스템이 최적화된 방식으로 그룹화하여 읽거나 개별 읽기로 폴백함
3. **Given** 50개 태그 배치 읽기 요청, **When** 읽기 수행, **Then** 전체 응답 시간이 개별 읽기 50회보다 현저히 빠름 (최소 5배 이상 빠름)

---

### User Story 4 - 연결 끊김 감지 및 자동 재연결 (Priority: P2)

PLC 연결이 끊어진 경우 이를 감지하고 자동으로 재연결을 시도한다.

**Why this priority**: 시스템 안정성과 복원력. 실제 운영 환경에서는 네트워크 문제나 PLC 재부팅으로 연결이 끊어질 수 있다. 자동 재연결이 없으면 수동 개입이 필요하다.

**Independent Test**: PLC 연결을 강제로 끊고 (네트워크 차단 또는 PLC 전원 끄기), 시스템이 연결 끊김을 감지하고 자동으로 재연결을 시도하는지 확인. 재연결 로그 확인.

**Acceptance Scenarios**:

1. **Given** PLC01과 정상 연결된 상태, **When** 네트워크 케이블이 뽑히거나 PLC 전원이 꺼짐, **Then** 다음 읽기 요청 시 연결 끊김이 감지되고 로그에 기록됨
2. **Given** PLC 연결이 끊어진 상태로 감지됨, **When** 시스템이 재연결을 시도함, **Then** 설정된 재시도 횟수(예: 3회)와 간격(예: 5초)에 따라 재연결 시도하고 결과를 로깅함
3. **Given** 재연결 시도 중, **When** PLC가 다시 온라인 상태가 됨, **Then** 연결이 복구되고 정상 동작 재개됨
4. **Given** 재시도 횟수를 초과했지만 재연결 실패, **When** 최종 실패 확정, **Then** 해당 PLC를 비활성 상태로 마킹하고 알람 로그 기록

---

### User Story 5 - 타임아웃 처리 및 에러 복구 (Priority: P3)

PLC 응답이 지연되거나 에러가 발생했을 때 적절히 처리하고 복구한다.

**Why this priority**: 시스템 강건성. P1, P2 기능이 정상 작동 후 예외 상황 처리를 보강하는 단계.

**Independent Test**: PLC 응답을 의도적으로 지연시키거나 (방화벽 규칙으로 지연 추가) 잘못된 응답을 보내고, 타임아웃과 에러 처리가 올바르게 작동하는지 확인.

**Acceptance Scenarios**:

1. **Given** PLC 연결 타임아웃이 5초로 설정됨, **When** PLC가 5초 이상 응답하지 않음, **Then** 타임아웃 에러가 발생하고 로그에 기록되며, 해당 연결이 풀에서 제거됨
2. **Given** PLC가 프로토콜 에러 응답을 보냄, **When** 에러 응답 수신, **Then** 에러 내용이 파싱되고 로그에 기록되며, 적절한 에러 메시지가 상위 레이어로 전달됨
3. **Given** 연속해서 3회 이상 타임아웃 또는 에러 발생, **When** 에러 임계값 초과, **Then** 해당 PLC 연결을 일시적으로 비활성화하고 재연결 로직 실행

---

### Edge Cases

- PLC 풀의 모든 연결이 사용 중일 때 새로운 요청이 들어오면? → 대기 또는 타임아웃
- 배치 읽기 중 일부 태그는 성공하고 일부는 실패하면? → 부분 성공 결과를 반환하고 실패한 태그는 에러 표시
- 재연결 시도 중에 새로운 읽기 요청이 들어오면? → 재연결 완료까지 대기 또는 즉시 에러 반환
- PLC가 예상과 다른 프로토콜 버전을 사용하면? → 프로토콜 불일치 에러 로깅 및 재연결 시도
- 네트워크가 매우 느려서 응답 시간이 50ms를 초과하면? → 타임아웃 임계값까지 대기하고, 성능 저하 경고 로깅

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 시스템은 SQLite DB의 plc_connections 테이블에서 PLC 연결 정보(IP 주소, 포트, 프로토콜)를 읽을 수 있어야 함
- **FR-002**: 시스템은 Mitsubishi Q Series PLC와 MC 3E ASCII 프로토콜로 TCP/IP 소켓 연결을 수립할 수 있어야 함
- **FR-003**: 시스템은 PLC당 최대 5개의 연결을 Connection Pool로 관리해야 함
- **FR-004**: 시스템은 연결을 재사용하여 동일한 PLC에 대한 반복 요청 시 새 연결을 생성하지 않아야 함
- **FR-005**: 시스템은 단일 태그 주소(예: D100)를 읽어서 값을 반환할 수 있어야 함
- **FR-006**: 시스템은 10~50개의 연속된 태그 주소를 배치로 읽을 수 있어야 함
- **FR-007**: 시스템은 읽기 요청에 대해 설정된 타임아웃(기본 5초) 이내에 응답하거나 타임아웃 에러를 반환해야 함
- **FR-008**: 시스템은 PLC 연결 끊김을 감지할 수 있어야 함
- **FR-009**: 시스템은 연결 끊김 감지 시 설정된 재시도 횟수(기본 3회)와 간격(기본 5초)에 따라 자동 재연결을 시도해야 함
- **FR-010**: 시스템은 재연결 실패 시 해당 PLC를 비활성 상태로 표시하고 알람 로그를 기록해야 함
- **FR-011**: 시스템은 모든 PLC 통신 이벤트(연결, 끊김, 재연결, 에러)를 로그에 기록해야 함
- **FR-012**: 시스템은 풀의 유휴 연결을 정리하여 리소스를 회수해야 함 (유휴 타임아웃: 10분)
- **FR-013**: 시스템은 PLC 프로토콜 에러 응답을 파싱하고 의미 있는 에러 메시지로 변환해야 함
- **FR-014**: 시스템은 동시에 여러 PLC에 대한 연결 풀을 관리할 수 있어야 함 (최대 10개 PLC 지원)
- **FR-015**: 시스템은 연결 풀의 현재 상태(사용 중/유휴 연결 수)를 조회할 수 있어야 함

### Key Entities

- **PLC Connection**: PLC 연결 정보를 나타냄. 속성: PLC 코드, IP 주소, 포트, 프로토콜 타입, 연결 타임아웃, 활성 상태, 마지막 연결 시간
- **Connection Pool**: PLC당 관리되는 연결 풀. 속성: PLC ID, 최대 연결 수, 현재 활성 연결 목록, 유휴 연결 목록, 풀 상태
- **Tag**: 읽을 태그 정보. 속성: 태그 주소, 태그 이름, 태그 타입, 연관된 PLC ID
- **Read Request**: 태그 읽기 요청. 속성: 요청 ID, PLC ID, 태그 주소 목록, 타임아웃, 요청 시간
- **Read Response**: 태그 읽기 응답. 속성: 요청 ID, 성공/실패 여부, 태그 값 목록, 에러 메시지, 응답 시간

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 단일 태그 읽기 요청에 대해 95% 이상이 50ms 이내에 응답을 받음
- **SC-002**: 배치 읽기(50개 태그)가 개별 읽기 50회 대비 최소 5배 이상 빠름 (500ms vs 2500ms)
- **SC-003**: Connection Pool을 사용하여 동일 PLC에 대한 10회 연속 요청 시 새 연결 생성이 최대 5회까지만 발생함
- **SC-004**: PLC 연결 끊김 발생 시 30초 이내에 자동 재연결이 시도되고 결과가 로그에 기록됨
- **SC-005**: 타임아웃 설정값(5초) 이내에 응답하지 않는 요청은 100% 타임아웃 에러로 처리됨
- **SC-006**: 시스템이 동시에 10개의 서로 다른 PLC에 대한 연결 풀을 관리하고 정상적으로 통신할 수 있음
- **SC-007**: 연결 풀의 유휴 연결이 10분 이상 사용되지 않으면 자동으로 정리되어 리소스가 회수됨
- **SC-008**: PLC 통신 관련 모든 이벤트(성공, 실패, 재연결)가 100% 로그에 기록됨
- **SC-009**: 재연결 실패 후 PLC 비활성 상태 전환이 로그에 명확히 기록되고 운영자가 확인할 수 있음
- **SC-010**: 1,000개 태그를 배치로 읽을 때 (20개씩 50개 배치) 전체 소요 시간이 5초 이내

## Assumptions

- pymcprotocol 라이브러리가 Mitsubishi Q Series PLC의 MC 3E ASCII 프로토콜을 완전히 지원한다고 가정
- PLC는 MC 3E ASCII 프로토콜의 표준 사양을 따르고 있다고 가정
- 네트워크 대역폭은 PLC 통신에 충분하다고 가정 (최소 10Mbps)
- PLC는 동시에 최소 5개의 TCP 연결을 지원한다고 가정
- 태그 주소는 연속된 메모리 영역에 배치될 수 있다고 가정 (배치 읽기 최적화를 위해)
- SQLite DB의 plc_connections 테이블은 Feature 1에서 이미 생성되어 있다고 가정
- 시스템 시간이 정확하고 NTP 동기화되어 있다고 가정 (타임아웃 계산 정확성을 위해)

## Dependencies

- **Feature 1**: 프로젝트 기본 구조 및 SQLite 데이터베이스 설정 (plc_connections, tags 테이블 필요)
- pymcprotocol 라이브러리 (Python 패키지)
- Python 3.11+ 표준 라이브러리 (socket, threading, queue)
- 로깅 시스템 (Python logging 모듈)

## Out of Scope

- 태그 값의 데이터베이스 저장 (Feature 4에서 처리)
- 실시간 폴링 엔진 구현 (Feature 3에서 처리)
- WebSocket을 통한 실시간 데이터 전송 (Feature 5에서 처리)
- PLC 쓰기(Write) 기능 (현재는 읽기만 지원)
- MC 프로토콜 외의 다른 PLC 프로토콜 지원 (Modbus, OPC UA 등)
- PLC 프로그램 다운로드 또는 디버깅 기능
- 암호화된 PLC 통신 (TLS/SSL)
- 사용자 인터페이스 (Feature 6, 7에서 처리)
